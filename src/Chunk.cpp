#include "Chunk.h"

Chunk::Chunk(glm::vec3 position, World* world)
{
	_position = position;
	_world = world;

	// Gen first time
	glGenBuffers(1, &_vbo);
	glGenVertexArrays(1, &_vao);

	// Create the blocks
	_blocks = new Block * *[CHUNK_WIDTH];
	for (int i = 0; i < CHUNK_WIDTH; i++)
	{
		_blocks[i] = new Block * [CHUNK_HEIGHT];

		for (int j = 0; j < CHUNK_HEIGHT; j++)
		{
			_blocks[i][j] = new Block[CHUNK_WIDTH];
		}
	}
}

Chunk::~Chunk()
{
	// Delete the blocks
	for (int i = 0; i < CHUNK_WIDTH; ++i)
	{
		for (int j = 0; j < CHUNK_HEIGHT; ++j)
		{
			delete[] _blocks[i][j];
		}

		delete[] _blocks[i];
	}
	delete[] _blocks;

	glDeleteVertexArrays(1, &_vao);
	glDeleteBuffers(1, &_vbo);
}

void Chunk::load()
{
	float*** heightMap = new float** [CHUNK_WIDTH];
	for (int i = 0; i < CHUNK_WIDTH; i++)
	{
		heightMap[i] = new float* [CHUNK_HEIGHT];

		for (int j = 0; j < CHUNK_HEIGHT; j++)
		{
			heightMap[i][j] = new float[CHUNK_WIDTH];
		}
	}

	// Input
	float scale = 0.75;
	int octaves = 5;
	float persistance = 0.2;
	float lacunarity = 1.4;
	glm::vec3 offset(0, 0, 0);

	float maxNoiseHeight = std::numeric_limits<float>::min();
	float minNoiseHeight = std::numeric_limits<float>::max();

	float halfWidth = CHUNK_WIDTH / 2;
	float halfHeight = CHUNK_HEIGHT / 2;

	float maxPossibleHeight = 0; // Maximum possible height generated by the noise generator below
	float amplitude = 1;
	float frequency = 1;

	srand(_world->getSeed());

	glm::vec3* octaveOffsets = new glm::vec3[octaves];

	for (int i = 0; i < octaves; i++) {
		float offSetX = (rand() % (100000 - -100000) + -100000) + offset.x;
		float offSetY = (rand() % (100000 - -100000) + -100000) + offset.y;
		float offSetZ = (rand() % (100000 - -100000) + -100000) + offset.z;
		octaveOffsets[i] = glm::vec3(offSetX, offSetY, offSetZ);

		maxPossibleHeight += amplitude;
		amplitude *= persistance;
	}

	// Build height map
	for (int x = 0; x < CHUNK_WIDTH; x++)
		for (int y = 0; y < CHUNK_HEIGHT; y++)
			for (int z = 0; z < CHUNK_WIDTH; z++)
			{
				amplitude = 1;
				frequency = 1;
				float noiseHeight = 0;

				// Loop through octaves
				for (int i = 0; i < octaves; i++)
				{
					float sampleX = ((_position.x + x) - halfWidth + octaveOffsets[i].x) / scale * frequency;
					float sampleY = ((_position.y + y) - halfHeight + octaveOffsets[i].y) / scale * frequency;
					float sampleZ = ((_position.z + z) - halfWidth + octaveOffsets[i].z) / scale * frequency;

					float perlinValue = _world->getNoise().GetNoise(sampleX, sampleY, sampleZ) * 2 - 1;
					noiseHeight += perlinValue * amplitude;

					amplitude *= persistance;
					frequency += lacunarity;

					if (noiseHeight > maxNoiseHeight)
					{
						maxNoiseHeight = noiseHeight;
					}
					else if (noiseHeight < minNoiseHeight)
					{
						minNoiseHeight = noiseHeight;
					}

					heightMap[x][y][z] = noiseHeight;
				}
			}

	// Normalize height map
	for (int x = 0; x < CHUNK_WIDTH; x++)
		for (int y = 0; y < CHUNK_HEIGHT; y++)
			for (int z = 0; z < CHUNK_WIDTH; z++)
			{
				float normalizedHeight = (heightMap[x][y][z] + 1) / (2.0f * maxPossibleHeight);
				heightMap[x][y][z] = glm::clamp(normalizedHeight, 0.0f, std::numeric_limits<float>::max());
			}

	// Build terrain
	for (int y = 0; y < CHUNK_HEIGHT; y++)
		for (int x = 0; x < CHUNK_WIDTH; x++)
			for (int z = 0; z < CHUNK_WIDTH; z++)
			{
				float height = heightMap[x][y][z] * CHUNK_HEIGHT;

				if (y > height)
				{
					if (y <= 8) // Water Level
					{
						_blocks[x][y][z].setId(BlockManager::BLOCK_WATER);
					}

					continue;
				}
				else if (y == height)
				{
					if (y >= 8) // Water Level
					{
						_blocks[x][y][z].setId(BlockManager::BLOCK_GRASS);
					}
					else
					{
						_blocks[x][y][z].setId(BlockManager::BLOCK_WATER);
					}
				}
				else if (y > height - 3)
				{
					_blocks[x][y][z].setId(BlockManager::BLOCK_DIRT);
				}
				else
				{
					_blocks[x][y][z].setId(BlockManager::BLOCK_STONE);
				}
			}

	// Delete unused memory
	delete[] octaveOffsets;

	// Delete the blocks
	for (int i = 0; i < CHUNK_WIDTH; ++i)
	{
		for (int j = 0; j < CHUNK_HEIGHT; ++j)
		{
			delete[] heightMap[i][j];
		}

		delete[] heightMap[i];
	}
	delete[] heightMap;

	_loaded = true;
}

void Chunk::render()
{
	// Set the position of this chunk in the shader
	_world->getWorldShader()->setMat4("model", _modelMatrix);

	// Render
	glBindVertexArray(_vao);
	glDrawArrays(GL_TRIANGLES, 0, _vertices);
	glBindVertexArray(0);
}

bool Chunk::isTransparent(int x, int y, int z)
{
	if (y < 0) return false;

	if (getBlockType(x, y, z) == BlockManager::BLOCK_AIR)
		return true;

	return false;
}

unsigned int Chunk::getBlockType(int x, int y, int z)
{
	if ((y >= CHUNK_HEIGHT))
		return BlockManager::BLOCK_AIR;

	if ((x < 0) || (z < 0) || (x >= CHUNK_WIDTH) || (z >= CHUNK_WIDTH))
	{
		// Calculate world coordinates
		glm::vec3 worldPos(x, y, z);
		worldPos += _position;

		// Find the chunk that contains these coordinates
		Chunk* c = _world->findChunk(worldPos);

		// This is "air", render the side of the face
		if (c == NULL || !c->isLoaded())
			return 0;

		// Calculate local space coordinates
		glm::vec3 cLocal = worldPos -= c->getPosition();
		return c->getBlockType(cLocal.x, cLocal.y, cLocal.z);
	}

	return _blocks[x][y][z].getId();
}

void Chunk::rebuild()
{
	std::vector<ChunkVertex> vertices;

	for (int x = 0; x < CHUNK_WIDTH; x++) {
		for (int y = 0; y < CHUNK_HEIGHT; y++) {
			for (int z = 0; z < CHUNK_WIDTH; z++) {
				// Get the id at this position
				Block b = _blocks[x][y][z];

				// Don't render Air
				if (b.getId() == BlockManager::BLOCK_AIR)
					continue;

				// Get block data
				glm::vec3 color = BlockManager::getColorFromId(b.getId());

				// Front
				if (isTransparent(x, y, z - 1))
				{
					vertices.push_back(ChunkVertex(1 + x, 1 + y, 0 + z, 0, 0, -1, color));
					vertices.push_back(ChunkVertex(1 + x, 0 + y, 0 + z, 0, 0, -1, color));
					vertices.push_back(ChunkVertex(0 + x, 0 + y, 0 + z, 0, 0, -1, color));

					vertices.push_back(ChunkVertex(0 + x, 0 + y, 0 + z, 0, 0, -1, color));
					vertices.push_back(ChunkVertex(0 + x, 1 + y, 0 + z, 0, 0, -1, color));
					vertices.push_back(ChunkVertex(1 + x, 1 + y, 0 + z, 0, 0, -1, color));
				}

				// Back
				if (isTransparent(x, y, z + 1))
				{
					vertices.push_back(ChunkVertex(0 + x, 0 + y, 1 + z, 0, 0, 1, color));
					vertices.push_back(ChunkVertex(1 + x, 0 + y, 1 + z, 0, 0, 1, color));
					vertices.push_back(ChunkVertex(1 + x, 1 + y, 1 + z, 0, 0, 1, color));

					vertices.push_back(ChunkVertex(1 + x, 1 + y, 1 + z, 0, 0, 1, color));
					vertices.push_back(ChunkVertex(0 + x, 1 + y, 1 + z, 0, 0, 1, color));
					vertices.push_back(ChunkVertex(0 + x, 0 + y, 1 + z, 0, 0, 1, color));
				}

				// Right
				if (isTransparent(x - 1, y, z))
				{
					vertices.push_back(ChunkVertex(0 + x, 1 + y, 1 + z, -1, 0, 0, color));
					vertices.push_back(ChunkVertex(0 + x, 1 + y, 0 + z, -1, 0, 0, color));
					vertices.push_back(ChunkVertex(0 + x, 0 + y, 0 + z, -1, 0, 0, color));

					vertices.push_back(ChunkVertex(0 + x, 0 + y, 0 + z, -1, 0, 0, color));
					vertices.push_back(ChunkVertex(0 + x, 0 + y, 1 + z, -1, 0, 0, color));
					vertices.push_back(ChunkVertex(0 + x, 1 + y, 1 + z, -1, 0, 0, color));
				}

				// Left
				if (isTransparent(x + 1, y, z))
				{
					vertices.push_back(ChunkVertex(1 + x, 0 + y, 0 + z, 1, 0, 0, color));
					vertices.push_back(ChunkVertex(1 + x, 1 + y, 0 + z, 1, 0, 0, color));
					vertices.push_back(ChunkVertex(1 + x, 1 + y, 1 + z, 1, 0, 0, color));

					vertices.push_back(ChunkVertex(1 + x, 1 + y, 1 + z, 1, 0, 0, color));
					vertices.push_back(ChunkVertex(1 + x, 0 + y, 1 + z, 1, 0, 0, color));
					vertices.push_back(ChunkVertex(1 + x, 0 + y, 0 + z, 1, 0, 0, color));
				}

				// Down
				if (isTransparent(x, y - 1, z))
				{
					vertices.push_back(ChunkVertex(0 + x, 0 + y, 0 + z, 0, -1, 0, color));
					vertices.push_back(ChunkVertex(1 + x, 0 + y, 0 + z, 0, -1, 0, color));
					vertices.push_back(ChunkVertex(1 + x, 0 + y, 1 + z, 0, -1, 0, color));

					vertices.push_back(ChunkVertex(1 + x, 0 + y, 1 + z, 0, -1, 0, color));
					vertices.push_back(ChunkVertex(0 + x, 0 + y, 1 + z, 0, -1, 0, color));
					vertices.push_back(ChunkVertex(0 + x, 0 + y, 0 + z, 0, -1, 0, color));
				}

				if (isTransparent(x, y + 1, z))
				{
					vertices.push_back(ChunkVertex(1 + x, 1 + y, 1 + z, 0, 1, 0, color));
					vertices.push_back(ChunkVertex(1 + x, 1 + y, 0 + z, 0, 1, 0, color));
					vertices.push_back(ChunkVertex(0 + x, 1 + y, 0 + z, 0, 1, 0, color));

					vertices.push_back(ChunkVertex(0 + x, 1 + y, 0 + z, 0, 1, 0, color));
					vertices.push_back(ChunkVertex(0 + x, 1 + y, 1 + z, 0, 1, 0, color));
					vertices.push_back(ChunkVertex(1 + x, 1 + y, 1 + z, 0, 1, 0, color));
				}
			}
		}
	}

	// Set the number of vertices
	_vertices = vertices.size();

	// Bind Vertex Array Object
	glBindVertexArray(_vao);

	// Copy our vertices's array in a vertex buffer for OpenGL to use
	glBindBuffer(GL_ARRAY_BUFFER, _vbo);
	glBufferData(GL_ARRAY_BUFFER, sizeof(ChunkVertex) * _vertices, vertices.data(), GL_STATIC_DRAW);

	// position attribute
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(ChunkVertex), (void*)offsetof(ChunkVertex, Position));
	glEnableVertexAttribArray(0);

	// normal attribute
	glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(ChunkVertex), (void*)offsetof(ChunkVertex, Normal));
	glEnableVertexAttribArray(1);

	// color attribute
	glVertexAttribPointer(2, 3, GL_FLOAT, GL_FALSE, sizeof(ChunkVertex), (void*)offsetof(ChunkVertex, Color));
	glEnableVertexAttribArray(2);

	// Setup world position
	_modelMatrix = glm::translate(glm::mat4(1.0f), _position);

	// The chunk has been rebuilt
	_changed = false;
}